import { TBemPlusClassGeneratorConfigOutput } from './schema'
import fs from 'fs'
import { glob } from 'glob'
import { camel, pascal, unique } from '../helpers'
import { moduleTemplate } from './templates/module'
import { elementClassTemplate } from './templates/elementClass'
import { modifierTemplate } from './templates/modifier'
import { elementReferenceTemplate } from './templates/elementReference'
import { rootReferenceTemplate } from './templates/rootReference'
import { elementPropertyTemplate } from './templates/elementProperty'
import { importExportTemplate } from './templates/importExport'
import * as path from 'node:path'
import { TIndex, TBlock, EOutputMode, EOutputLanguage, EStrategy, TElement } from './types'

const AUTO_GENERATED_DISCLAIMER = 'This file was automatically generated by the bem-plus package.'

export class BemPlusClassGenerator {
    index: TIndex = {}
    outputPath: string
    matchers = {
        dist: {
            bemSeparator: new RegExp(`${this.config.input.separators.element}|${this.config.input.separators.modifier}`),
            blockElement: new RegExp(`[^(\\d.\\n]*${this.config.input.separators.element}.+?(?=${this.config.input.separators.modifier}|[ .,[:#{)>+])`, 'g'),
            blockElementModifier: new RegExp(`(?<!(var\\(|{|;))[^(\\d.\\n!{]*${this.config.input.separators.modifier}[^ .,[:#{)>+]*`, 'g')
        },
        scss: {
            element: (block: string) => new RegExp(`(?<=&${this.config.input.separators.element})[^ {(]*(?=.*\\n.*@include ${block}${this.config.input.separators.mixinElement})`, 'g'),
            elementProps: (block: string, element: string) => new RegExp(`(?<=@mixin ${block}${this.config.input.separators.mixinElement}${element}.*\\()[^)]*`, 'g'),
            hasIndex: (block: string) => new RegExp(`@mixin ${block}([ \\t(]*[({]|[\\s\\S]).*[\\s\\S].*\\.${block}`),
            hasAnElement: (block: string) => new RegExp(`@mixin ${block}${this.config.input.separators.mixinElement}.*`),
            removeComments: (input: string) => input.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*/g, '')
        }
    }

    constructor(public config: TBemPlusClassGeneratorConfigOutput, public distPath: string) {
        this.outputPath = config.output.mode === EOutputMode.node_modules ? '/node_modules/@bem-plus/generated' : config.output.path
    }

    async generate() {
        this.validateSeparators()

        const dist = await this.getBuiltContent()
        const modifiers: string[] = dist.match(this.matchers.dist.blockElementModifier) || []

        if (this.config.strategy === EStrategy.plus) {
            const blocks = await this.getPlusBlocks(dist)

            this.index = await this.createIndex({
                blocks,
                elements: this.getPlusElements(blocks),
                modifiers
            })
        }
        else {
            const elements: string[] = dist.match(this.matchers.dist.blockElement) || []

            this.index = await this.createIndex({
                blocks: this.getBlocksFromDist(elements, modifiers),
                elements,
                modifiers
            })
        }

        await this.writeModules()
        await this.clearObsoleteModules()
        await this.createBarrel()

        this.config.output.onComplete()
    }

    validateSeparators() {
        if (['-', ''].includes(this.config.input.separators.modifier)) {

        }

        if (['-', ''].includes(this.config.input.separators.element)) {

        }

        if (['--', '__'].includes(this.config.input.separators.mixinElement)) {

        }
    }

    getBlocksFromDist(elements: string[], modifiers: string[]): TBlock[] {
        const blocksFromElements = elements.map((element) => element.split(this.config.input.separators.element)[0])
        const blocksFromModifiers = modifiers.map((modifier) => modifier.split(this.matchers.dist.bemSeparator)[0])

        return unique([...blocksFromElements, ...blocksFromModifiers])
            .filter((block) => !this.config.input.excludeBlocks.includes(block))
            .map((block) => ({
                name: block,
                input: '',
                output: this.getPath(block)
            }))
    }

    getPlusElements(blocks: TBlock[]) {
        return blocks.flatMap((block) => {
            const matches = block.input.match(this.matchers.scss.element(block.name))

            return matches ? matches.map((match) => `${block.name}${this.config.input.separators.element}${match.trim()}`) : []
        })
    }

    async getFileContents(paths: string[]) {
        const filePromises = paths.map((filePath) => fs.promises.readFile(filePath))
        const settled = await Promise.allSettled(filePromises)

        return settled.map((result) => {
            if (result.status === 'fulfilled') {
                return {
                    success: true,
                    contents: result.value.toString()
                }
            }

            return {
                success: false,
                contents: ''
            }
        })
    }

    async getBuiltContent() {
        const filePaths = await glob(`${this.distPath}/**/*.css`)
        const fileContents = await this.getFileContents(filePaths)

        return fileContents.map((fileContents) => fileContents.contents).join(' ')
    }

    getPath(block: string, outputPath = this.outputPath) {
        const absolutePath = path.resolve(outputPath, this.config.output.filename(block, this.config.output.language))

        return path.relative(process.cwd(), absolutePath)
    }

    async getPlusBlocks(dist: string): Promise<TBlock[]> {
        const filePaths = await glob(this.config.input.include, {
            ignore: this.config.input.exclude
        })

        const fileNames = filePaths.map((filePath) => {
            const fileName = path.parse(filePath).name

            return fileName.startsWith('_') ? fileName.substring(1) : fileName
        })

        const filePathsThatNeedContent = filePaths.filter((filePath, k) => dist.includes(`.${fileNames[k]}`))
        const blockContentPromises = filePathsThatNeedContent.map((filePath) => fs.promises.readFile(filePath))

        const blockContents = await Promise.all(blockContentPromises)
            .then((contents) => contents.map((c) => c.toString()))

        const resolvedBlocks = filePathsThatNeedContent.map((filePath, k) => {
            const fileName = path.parse(filePath).name
            const block = fileName.startsWith('_') ? fileName.substring(1) : fileName

            return {
                name: block,
                input: this.matchers.scss.removeComments(blockContents[k]),
                output: this.getPath(
                    block,
                    this.config.output.mode === EOutputMode.relative ? path.dirname(filePath) : this.outputPath
                )
            }
        })

        return resolvedBlocks.filter((block) => !this.config.input.excludeBlocks.includes(block.name))
    }

    getElementProps(block: TBlock, element: string) {
        const match = block.input.match(this.matchers.scss.elementProps(block.name, element))
        const props: { [key: string]: string } = {}

        if (match?.length) {
            const propStrings = match[0].substring(1).split(/,[ \t]*\$/g)
            propStrings.forEach((propString) => {
                const keyValue = propString.split(':')
                props[keyValue[0].trim()] = keyValue[1].trim()
            })
        }

        return props
    }

    verifyFileIsBlock(block: TBlock) {
        const oneElementMatch = block.input.match(this.matchers.scss.hasAnElement(block.name))
        const hasIndexMatch = block.input.match(this.matchers.scss.hasIndex(block.name))

        return oneElementMatch?.length && hasIndexMatch?.length
    }

    async createIndex({
        blocks, elements, modifiers
    }: { blocks: TBlock[], elements: string[], modifiers: string[] }) {
        const index: TIndex = {}

        blocks.forEach((block) => {
            const rootModifiers = unique(modifiers.filter((modifier) => modifier.startsWith(`${block.name}${this.config.input.separators.modifier}`)))
            const rootModifierNames = rootModifiers.map((modifier) => {
                return modifier.split(this.config.input.separators.modifier).pop()!
            })

            const rootProps = this.getElementProps(block, 'root')
            const rootType = rootProps.type ?? 'HTMLElement'

            if (!this.verifyFileIsBlock(block) && this.config.strategy === EStrategy.plus) {
                return
            }

            index[block.name] = {
                ...block,
                elements: {
                    root: {
                        name: 'root',
                        type: rootType,
                        modifiers: rootModifierNames
                    }
                }
            }

            const elementsOfThisBlock = unique(elements.filter((element) => element.startsWith(block.name)))

            elementsOfThisBlock.forEach((element) => {
                const elementName = element.split(this.config.input.separators.element).pop()!
                const modifiersOfThisElement = unique(modifiers.filter((modifier) => modifier.startsWith(element)))
                const modifierNames = modifiersOfThisElement.map((modifier) => {
                    return modifier.split(this.config.input.separators.modifier).pop()!
                })

                const elementProps = this.getElementProps(block, elementName)
                const elementType = elementProps.type ?? 'HTMLElement'

                index[block.name].elements[elementName] = {
                    name: elementName,
                    type: elementType,
                    modifiers: modifierNames
                }
            })

            const isTypeScript = this.config.output.language === EOutputLanguage.ts

            const rootReference = rootReferenceTemplate({
                isTypeScript,
                className: pascal(block.name)
            })

            index[block.name].contents = moduleTemplate({
                isTypeScript,
                ...this.generateElementTemplateStrings(
                    block.name,
                    Object.values(index[block.name].elements),
                    isTypeScript
                ),
                className: pascal(
                    this.config.output.moduleClassPrefix,
                    block.name,
                    this.config.output.moduleClassSuffix
                ),
                rootReference,
                prefix: this.config.output.prefix,
                suffix: this.config.output.suffix,
                autoGeneratedDisclaimer: AUTO_GENERATED_DISCLAIMER
            })
        })

        return index
    }

    generateElementTemplateStrings(block: string, elements: TElement[], isTypeScript: boolean) {
        const elementClasses: string[] = []
        const elementReferences: string[] = []
        const elementProperties: string[] = []

        Object.values(elements).forEach((element) => {
            const modifierProperties = element.modifiers.map((modifier) => {
                return modifierTemplate({
                    block,
                    element: element.name === 'root' ? '' : element.name,
                    modifier,
                    isTypeScript,
                    separators: this.config.input.separators
                })
            })

            const className = pascal(
                this.config.output.elementClassPrefix,
                block,
                element.name,
                this.config.output.elementClassSuffix
            )

            const elementClass = elementClassTemplate({
                isTypeScript,
                className,
                type: element.type,
                modifiers: modifierProperties.join('')
            })

            elementClasses.push(elementClass)

            if (element.name === 'root') {
                return
            }

            const elementReference = elementReferenceTemplate({
                isTypeScript,
                className,
                block,
                element,
                separators: this.config.input.separators
            })

            elementReferences.push(elementReference)

            const elementProperty = elementPropertyTemplate({
                isTypeScript,
                className,
                element: element.name
            })

            elementProperties.push(elementProperty)
        })

        return {
            elementClasses: elementClasses.join('\n'),
            elementReferences: elementReferences.join('\n'),
            elementProperties: elementProperties.join('\n')
        }
    }

    async writeModules() {
        await fs.promises.mkdir(this.outputPath, {
            recursive: true
        })

        if (this.config.strategy === EStrategy.dist && this.config.output.mode === EOutputMode.relative) {
            console.warn(`bem-plus: Relative output mode is not supported for "dist" strategy. Your files will be generated here: ${this.config.output.path}`)
        }

        const mkdirPaths = Object.values(this.index)
            .filter((block) => block.output.includes('/'))
            .map((block) => path.relative(process.cwd(), path.dirname(block.output)))

        const mkdirPromises = unique(mkdirPaths).map((mkdirPath) => {
            return fs.promises.mkdir(mkdirPath, {
                recursive: true
            })
        })

        await Promise.all(mkdirPromises)

        const writeFilePromises = Object.values(this.index).map((block) => {
            return fs.promises.writeFile(block.output, block.contents ?? '', {
                flag: 'w'
            }).then(() => {
                console.log(`Generated ${block.output}`)
            })
        })

        await Promise.all(writeFilePromises)
    }

    async clearObsoleteModules() {
        const otherExt = this.config.output.language === EOutputLanguage.ts ? EOutputLanguage.js : EOutputLanguage.ts
        let index = await this.getFileContents([path.resolve(this.config.output.path, `index.${this.config.output.language}`)])

        if (!index[0].success) {
            index = await this.getFileContents([path.resolve(this.config.output.path, `index.${otherExt}`)])

            if (!index[0].success) {
                return
            }
        }

        const oldModulePaths = (index[0].contents.match(/(?<=export \* from ['"`]).*(?=['"`])/g) || [])
            .map((oldRelativePath) => path.resolve(this.config.output.path, oldRelativePath))

        const newModulePaths = Object.values(this.index).map((block) => {
            const parsed = path.parse(block.output)

            return path.resolve(path.join(parsed.dir, parsed.name))
        })

        const obsoleteModulePaths = oldModulePaths
            .filter((oldModulePath) => !newModulePaths.includes(oldModulePath))
            .map((oldModulePath) => path.resolve(this.config.output.path, oldModulePath))

        const obsoleteModulePathsWithCurrentExt = obsoleteModulePaths.map((obsoleteModulePath) => `${obsoleteModulePath}.${this.config.output.language}`)
        const fileContentsWithCurrentExt = await this.getFileContents(obsoleteModulePathsWithCurrentExt)
        const confirmedModules: string[] = []
        const retryWithOldExt: string[] = []

        fileContentsWithCurrentExt.forEach((fileContent, key) => {
            if (!fileContent.success) {
                retryWithOldExt.push(obsoleteModulePaths[key])
            } else if (fileContent.contents.includes(AUTO_GENERATED_DISCLAIMER)) {
                confirmedModules.push(obsoleteModulePathsWithCurrentExt[key])
            }
        })

        if (retryWithOldExt.length) {
            const obsoleteModulePathsWithOldExt = retryWithOldExt.map((obsoleteModulePath) => `${obsoleteModulePath}.${otherExt}`)
            const fileContentsWithOldExt = await this.getFileContents(obsoleteModulePathsWithOldExt)

            fileContentsWithOldExt.forEach((fileContent, key) => {
                if (fileContent.success && fileContent.contents.includes(AUTO_GENERATED_DISCLAIMER)) {
                    confirmedModules.push(obsoleteModulePathsWithCurrentExt[key])
                }
            })
        }

        const unlinkPromises = confirmedModules.map((obsoleteModule) => {
            const fullPath = path.resolve(this.config.output.path, obsoleteModule)

            return fs.promises.unlink(fullPath)
        })

        await Promise.all(unlinkPromises)

        unique(confirmedModules.map((module) => path.dirname(module))).forEach((dir) => {
            this.recursivelyDeleteEmptyDir(dir)
        })
    }

    recursivelyDeleteEmptyDir(dir: string) {
        const isEmpty = fs.readdirSync(dir).length === 0

        if (isEmpty) {
            fs.rmdirSync(dir)
            this.recursivelyDeleteEmptyDir(path.resolve(dir, '..'))
        }
    }

    async createBarrel() {
        const imports: { [key: string]: string } = {}

        Object.entries(this.index).forEach(([indexKey, indexValue]) => {
            const relativePath = path.relative(this.config.output.path, indexValue.output)
            const pathWithoutExt = relativePath.split('.').slice(0, -1).join('.')
            const fullPath = pathWithoutExt.startsWith('.') ? pathWithoutExt : `./${pathWithoutExt}`
            imports[camel(indexKey)] = importExportTemplate(fullPath)
        })

        const autoGeneratedDisclaimerString = `/* ${AUTO_GENERATED_DISCLAIMER} */`
        const importsString = Object.values(imports).join('\n')
        const fullIndex = `${autoGeneratedDisclaimerString}\n\n${importsString}`
        const fileName = `index.${this.config.output.language}`
        const filePath = path.resolve(this.config.output.path, fileName)

        await fs.promises.writeFile(filePath, fullIndex, {
            flag: 'w'
        })
    }
}

