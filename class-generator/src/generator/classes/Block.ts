import { moduleTemplate } from '../templates/module'
import { getFileContents, pascal } from '../../helpers'
import { EOutputLanguage } from '../types'
import { TBemPlusClassGeneratorProjectConfig } from '../schema'
import { rootReferenceTemplate } from '../templates/rootReference'
import { Element } from './Element'
import fs from 'fs'
import path from 'node:path'
import { importExportTemplate } from '../templates/importExport'
import { AUTO_GENERATED_DISCLAIMER } from '../const'

export class Block {
    elements: Element[] = []
    output = ''
    module = ''
    importExport = ''
    autoloader = ''

    constructor (public config: TBemPlusClassGeneratorProjectConfig, public name = '') {
    }

    generateModule = (rootType = 'HTMLElement') => {
        const isTypeScript = this.config.output.language === EOutputLanguage.ts

        const rootReference = rootReferenceTemplate({
            type: rootType,
            isTypeScript,
            className: pascal(this.name)
        })

        const elementTemplates = this.elements.map((element) => element.generateTemplates(this.name, isTypeScript))

        return moduleTemplate({
            rootSelector: `.${this.name}`,
            type: rootType,
            isTypeScript,
            elementClasses: elementTemplates.map((templateGroup) => templateGroup.class).join('\n'),
            elementProperties: elementTemplates.map((templateGroup) => templateGroup.property).filter((prop) => prop.length).join('\n'),
            elementReferences: elementTemplates.map((templateGroup) => templateGroup.reference).filter((ref) => ref.length).join('\n'),
            className: this.config.output.moduleClass(pascal(this.name)),
            rootReference,
            prefix: this.config.output.prefix,
            suffix: this.config.output.suffix,
            autoGeneratedDisclaimer: AUTO_GENERATED_DISCLAIMER
        })
    }

    getImportExport = () => {
        const relativePath = path.relative(this.config.output.path, this.output)
        const pathWithoutExt = relativePath.split('.').slice(0, -1).join('.')
        const fullPath = pathWithoutExt.startsWith('.') ? pathWithoutExt : `./${pathWithoutExt}`

        return importExportTemplate(fullPath)
    }

    getAutoloader = async (): Promise<string> => {
        return await new Promise(() => '')
    }

    writeModule = async () => {
        this.autoloader = await this.getAutoloader()

        const filePath = path.dirname(this.output)

        if (!this.module.length) {
            return
        }

        if (!fs.existsSync(filePath)) {
            await fs.promises.mkdir(filePath, {
                recursive: true
            })
        }

        const existing = await getFileContents([this.output])

        if (existing.length) {
            if (JSON.stringify(existing[0].contents) !== JSON.stringify(this.module)) {
                await fs.promises.writeFile(this.output, this.module, {
                    flag: 'w'
                })
            }
        }
    }

    init = async () => {
    }
}
