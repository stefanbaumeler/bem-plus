import { Block } from './Block'
import { AUTO_GENERATED_DISCLAIMER } from '../const'
import path from 'node:path'
import fs from 'fs'
import { TBemPlusClassGeneratorProjectConfig } from '../schema'
import { EOutputLanguage } from '../types'
import { unique, getFileContents } from '../../helpers'

export class Barrel {
    matchers = {
        export: new RegExp('(?<=export \\* from [\'"`]).*(?=[\'"`])', 'g')
    }
    constructor (public config: TBemPlusClassGeneratorProjectConfig, public blocks: Block[]) {
    }

    write = async () => {
        const autoGeneratedDisclaimerString = `/* ${AUTO_GENERATED_DISCLAIMER} */`
        const importsString = this.blocks.filter((block) => block.module.length).map((block) => block.importExport).join('\n')
        const fullIndex = `${autoGeneratedDisclaimerString}\n\n${importsString}`
        const fileName = `index.${this.config.output.language}`
        const filePath = path.resolve(this.config.output.path, fileName)

        const existing = await getFileContents([filePath])

        if (existing.length) {
            if (JSON.stringify(existing[0].contents) !== JSON.stringify(fullIndex)) {
                await fs.promises.writeFile(filePath, fullIndex, {
                    flag: 'w'
                })
            }
        }
    }

    clearObsoleteModules = async () => {
        const otherExt = this.config.output.language === EOutputLanguage.ts ? EOutputLanguage.js : EOutputLanguage.ts
        let index = await getFileContents([path.resolve(this.config.output.path, `index.${this.config.output.language}`)])

        if (!index[0].success) {
            index = await getFileContents([path.resolve(this.config.output.path, `index.${otherExt}`)])

            if (!index[0].success) {
                return
            }
        }

        const oldModulePaths = (index[0].contents.match(this.matchers.export) || [])
            .map((oldRelativePath) => path.resolve(this.config.output.path, oldRelativePath))

        const newModulePaths = this.blocks
            .filter((block) => block.module.length)
            .map((block) => {
                const parsed = path.parse(block.output)

                return path.resolve(path.join(parsed.dir, parsed.name))
            })

        const obsoleteModulePaths = oldModulePaths
            .filter((oldModulePath) => !newModulePaths.includes(oldModulePath))
            .map((oldModulePath) => path.resolve(this.config.output.path, oldModulePath))

        const obsoleteModulePathsWithCurrentExt = obsoleteModulePaths.map((obsoleteModulePath) => `${obsoleteModulePath}.${this.config.output.language}`)
        const fileContentsWithCurrentExt = await getFileContents(obsoleteModulePathsWithCurrentExt)
        const confirmedModules: string[] = []
        const retryWithOldExt: string[] = []

        fileContentsWithCurrentExt.forEach((fileContent, key) => {
            if (!fileContent.success) {
                retryWithOldExt.push(obsoleteModulePaths[key])
            } else if (fileContent.contents.includes(AUTO_GENERATED_DISCLAIMER)) {
                confirmedModules.push(obsoleteModulePathsWithCurrentExt[key])
            }
        })

        if (retryWithOldExt.length) {
            const obsoleteModulePathsWithOldExt = retryWithOldExt.map((obsoleteModulePath) => `${obsoleteModulePath}.${otherExt}`)
            const fileContentsWithOldExt = await getFileContents(obsoleteModulePathsWithOldExt)

            fileContentsWithOldExt.forEach((fileContent, key) => {
                if (fileContent.success && fileContent.contents.includes(AUTO_GENERATED_DISCLAIMER)) {
                    confirmedModules.push(obsoleteModulePathsWithCurrentExt[key])
                }
            })
        }

        const unlinkPromises = confirmedModules.map((obsoleteModule) => {
            const fullPath = path.resolve(this.config.output.path, obsoleteModule)

            return fs.promises.unlink(fullPath)
        })

        await Promise.all(unlinkPromises)

        unique(confirmedModules.map((module) => path.dirname(module))).forEach((dir) => {
            this.recursivelyDeleteEmptyDir(dir)
        })
    }

    recursivelyDeleteEmptyDir = (dir: string) => {
        const isEmpty = fs.readdirSync(dir).length === 0

        if (isEmpty) {
            fs.rmdirSync(dir)
            this.recursivelyDeleteEmptyDir(path.resolve(dir, '..'))
        }
    }
}
